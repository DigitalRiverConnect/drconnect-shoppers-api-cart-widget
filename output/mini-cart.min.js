
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("rq/almond", function(){});

define('util/Class',[], function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;
  // The base Class implementation (does nothing)
  var Class = function(){};
  
  // Create a new Class that inherits from this class
  Class.extend = function(prop) {
    var _super = this.prototype;
    
    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;
    
    // Copy the properties over onto the new prototype
    for (var name in prop) {
      // Check if we're overwriting an existing function
      prototype[name] = typeof prop[name] == "function" && 
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;
            
            // Add a new ._super() method that is the same method
            // but on the super-class
            this._super = _super[name];
            
            // The method only need to be bound temporarily, so we
            // remove it when we're done executing
            var ret = fn.apply(this, arguments);        
            this._super = tmp;
            
            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
    
    // The dummy class constructor
    function Class() {
      // All construction is actually done in the init method
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }
    
    // Populate our constructed prototype object
    Class.prototype = prototype;
    
    // Enforce the constructor to be what we expect
    Class.prototype.constructor = Class;

    // And make this class extendable
    Class.extend = arguments.callee;
    
    return Class;
  };
  
  return Class;
});
define('config',[], function() {
    // create a private connection object
    var config = {
        env: 'prod',
        connection : {},
        emptyOfferPop: 'SiteMerchandising_EmptyCart',
        defaultCurrency: 'USD',
        defaultLocale: 'en_US'
    };

    // store connection information for various environments
    // never a trailing slash
    config.connection.URI = {
        BASE_URL: null,
        DEV_BASE_URL: 'http://23.21.197.49',
        SYS_BASE_URL: 'http://23.21.197.49:2080',
        PRD_BASE_URL: 'https://api.digitalriver.com',
        CTE_BASE_URL: 'https://api-cte.digitalriver.com',
        VERSION: 'v1',
        ANONYMOUS_LOGIN: 'shoppers/token',
        CATEGORY_RESOURCE : 'shoppers/me/categories',
        CART_RESOURCE : 'shoppers/me/carts/active',
        OFFER_RESOURCE: 'shoppers/me/point-of-promotions',
        WEB_CHECKOUT : 'shoppers/me/carts/active/web-checkout',
        SHOPPER: 'shoppers/me',
        HOME_PAGE_OFFER : 'shoppers/me/point-of-promotions',
        LINE_ITEM_RESOURCE: 'shoppers/me/carts/active/line-items',
        PRODUCT_RESOURCE: 'shoppers/me/products'
    };

    // return a public interface
    return {
        getBaseUrl: function() {
            var self = this,
                c = config.connection.URI,
                uri;

            switch (self.getEnv()) {
            case 'dev':
                uri = c.DEV_BASE_URL;
                break;
            case 'sys':
                uri = c.SYS_BASE_URL;
                break;
            case 'cte':
                uri = c.CTE_BASE_URL;
                break;
            case 'prod':
                // the default.. fall through
            default:
                uri =  c.PRD_BASE_URL;
                break;
            }
            return uri;
        },

        getHomePageOfferUrl: function() {
            var self = this, c = config.connection.URI;

            return [
                self.getBaseUrl(),
                c.VERSION,
                c.OFFER_RESOURCE,
                config.homePagePop,
                "offers",
                config.homePageOfferId,
                "product-offers"].join("/");
        },

        getAnonymousLoginUri: function() {
            var self = this, c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.ANONYMOUS_LOGIN].join("/");
        },

        getTokenServiceUri : function() {
            return "https://store.digitalriver.com/store?Action=ShopDomain&Locale=en_US&SiteId=cpryce&Env=DESIGN";
        },

        getCategoryResourceUrl : function() {
            var self  = this, c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.CATEGORY_RESOURCE].join("/");
        },

        getCartResourceUrl: function() {
            var self = this, c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.CART_RESOURCE].join("/");
        },

        getWebCheckoutUrl : function() {
            var self = this, c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.WEB_CHECKOUT].join("/");
        },

        getEmptyOfferUrl : function() {
            var self = this, c = config.connection.URI;

            if (config.emptyOfferPop != null && config.emptyOfferId != null) {
                return [
                    self.getBaseUrl(),
                    c.VERSION,
                    c.OFFER_RESOURCE,
                    config.emptyOfferPop,
                    "offers",
                    config.emptyOfferId].join("/");
            }
        },

        getLineItemUrl: function() {
            var self = this, c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.LINE_ITEM_RESOURCE].join("/");
        },

        getProductResourceURL: function() {
            var self = this, c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.PRODUCT_RESOURCE].join("/");
        },

        getShopperUrl: function () {
            var self = this,  c = config.connection.URI;
            return [self.getBaseUrl(), c.VERSION, c.SHOPPER].join("/");
        },

        getEnv: function() {
            return config.env;
        },

        setEnv: function(v) {
            config.env = v;
        },

        getApiKey : function() {
            return config.apiKey;
        },

        setApiKey : function(k) {
            config.apiKey = k;
        },

        getDefaultCurrency : function() {
            return config.defaultCurrency;
        },

        setDefaultCurrency : function(c) {
            config.defaultCurrency = c;
        },

        getDefaultLocale : function() {
            return config.defaultLocale;
        },

        setDefaultLocale : function(l) {
            config.defaultLocale = l;
        },

        getEmptyOfferId : function() {
            return config.emptyOfferId;
        },

        setEmptyOfferId : function(id) {
            config.emptyOfferId = id;
        },

        getEmptyOfferPop : function() {
            return config.emptyOfferPop;
        },

        setEmptyOfferPop : function(popName) {
            config.emptyOfferPop = popName;
        }
    };
});

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /*jshint strict: false*/

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define('lib/q',definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {


// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick;
if (typeof process !== "undefined") {
    // node
    nextTick = process.nextTick;
} else if (typeof setImmediate === "function") {
    // In IE10, or use https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        nextTick = setImmediate.bind(window);
    } else {
        nextTick = setImmediate;
    }
} else {
    (function () {
        // linked list of tasks (single, with head node)
        var head = {task: void 0, next: null}, tail = head,
            maxPendingTicks = 2, pendingTicks = 0, queuedTasks = 0, usedTicks = 0,
            requestTick;

        function onTick() {
            // In case of multiple tasks ensure at least one subsequent tick
            // to handle remaining tasks in case one throws.
            --pendingTicks;

            if (++usedTicks >= maxPendingTicks) {
                // Amortize latency after thrown exceptions.
                usedTicks = 0;
                maxPendingTicks *= 4; // fast grow!
                var expectedTicks = queuedTasks && Math.min(queuedTasks - 1, maxPendingTicks);
                while (pendingTicks < expectedTicks) {
                    ++pendingTicks;
                    requestTick();
                }
            }

            while (queuedTasks) {
                --queuedTasks; // decrement here to ensure it's never negative
                head = head.next;
                var task = head.task;
                head.task = void 0;
                task();
            }

            usedTicks = 0;
        }

        nextTick = function (task) {
            tail = tail.next = {task: task, next: null};
            if (pendingTicks < ++queuedTasks && pendingTicks < maxPendingTicks) {
                ++pendingTicks;
                requestTick();
            }
        };

        if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            channel.port1.onmessage = onTick;
            requestTick = function () {
                channel.port2.postMessage(0);
            };

        } else {
            // old browsers
            requestTick = function () {
                setTimeout(onTick, 0);
            };
        }
    })();
}

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don�t need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Miller�s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
function uncurryThis(f) {
    var call = Function.call;
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

// generator related shims

function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

Q.longStackJumpLimit = 1;

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible (that is, if in V8), transform the error stack
    // trace by removing Node and Q cruft, then concatenating with
    // the stack trace of the promise we are ``done``ing. See #57.
    if (promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        error.stack = filterStackString(error.stack) +
            "\n" + STACK_JUMP_SEPARATOR + "\n" +
            filterStackString(promise.stack);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line)) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function isInternalFrame(stackLine) {
    var pieces = /at .+ \((.*):(\d+):\d+\)/.exec(stackLine);

    if (!pieces) {
        return false;
    }

    var fileName = pieces[1];
    var lineNumber = pieces[2];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (Error.captureStackTrace) {
        var fileName, lineNumber;

        var oldPrepareStackTrace = Error.prepareStackTrace;

        Error.prepareStackTrace = function (error, frames) {
            fileName = frames[1].getFileName();
            lineNumber = frames[1].getLineNumber();
        };

        // teases call of temporary prepareStackTrace
        // JSHint and Closure Compiler generate known warnings here
        /*jshint expr: true */
        new Error().stack;

        Error.prepareStackTrace = oldPrepareStackTrace;
        qFileName = fileName;
        return lineNumber;
    }
}

// end of shims
// beginning of real work

/**
 * Creates fulfilled promises from non-promises,
 * Passes Q promises through,
 * Coerces thenables to Q promises.
 */
function Q(value) {
    return resolve(value);
}

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Constructs a {promise, resolve} object.
 *
 * The resolver is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke the resolver with any value that is
 * not a function. To reject the promise, invoke the resolver with a rejection
 * object. To put the promise in the same state as another promise, invoke the
 * resolver with that other promise.
 */
Q.defer = defer;
function defer() {
    // if "pending" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the pending array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the ref promise because it handles both fully
    // resolved values and other promises gracefully.
    var pending = [], progressListeners = [], value;

    var deferred = object_create(defer.prototype);
    var promise = object_create(makePromise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (pending) {
            pending.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                value.promiseDispatch.apply(value, args);
            });
        }
    };

    promise.valueOf = function () {
        if (pending) {
            return promise;
        }
        var nearer = valueOf(value);
        if (isPromise(nearer)) {
            value = nearer; // shorten chain
        }
        return nearer;
    };

    if (Error.captureStackTrace && Q.longStackJumpLimit > 0) {
        Error.captureStackTrace(promise, defer);

        // Reify the stack into a string by using the accessor; this prevents
        // memory leaks as per GH-111. At the same time, cut off the first line;
        // it's always just "[object Promise]\n", as per the `toString`.
        promise.stack = promise.stack.substring(promise.stack.indexOf("\n") + 1);
    }

    function become(resolvedValue) {
        if (!pending) {
            return;
        }
        value = resolve(resolvedValue);
        array_reduce(pending, function (undefined, pending) {
            nextTick(function () {
                value.promiseDispatch.apply(value, pending);
            });
        }, void 0);
        pending = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = become;
    deferred.fulfill = function (value) {
        become(fulfill(value));
    };
    deferred.reject = function (exception) {
        become(reject(exception));
    };
    deferred.notify = function (progress) {
        if (pending) {
            array_reduce(progressListeners, function (undefined, progressListener) {
                nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        }
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param makePromise {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in makePromise
 */
Q.promise = promise;
function promise(makePromise) {
    var deferred = defer();
    fcall(
        makePromise,
        deferred.resolve,
        deferred.reject,
        deferred.notify
    ).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * put(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = makePromise;
function makePromise(descriptor, fallback, valueOf, exception, isException) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error("Promise does not support operation: " + op));
        };
    }

    var promise = object_create(makePromise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    if (valueOf) {
        promise.valueOf = valueOf;
    }

    if (isException) {
        promise.exception = exception;
    }

    return promise;
}

// provide thenables, CommonJS/Promises/A
makePromise.prototype.then = function (fulfilled, rejected, progressed) {
    return when(this, fulfilled, rejected, progressed);
};

makePromise.prototype.thenResolve = function (value) {
    return when(this, function () { return value; });
};

makePromise.prototype.thenReject = function (reason) {
    return when(this, function () { throw reason; });
};

// Chainable methods
array_reduce(
    [
        "isFulfilled", "isRejected", "isPending",
        "dispatch",
        "when", "spread",
        "get", "put", "set", "del", "delete",
        "post", "send", "invoke",
        "keys",
        "fapply", "fcall", "fbind",
        "all", "allResolved",
        "timeout", "delay",
        "catch", "finally", "fail", "fin", "progress", "done",
        "nfcall", "nfapply", "nfbind", "denodeify", "nbind",
        "ncall", "napply", "nbind",
        "npost", "nsend", "ninvoke",
        "nodeify"
    ],
    function (undefined, name) {
        makePromise.prototype[name] = function () {
            return Q[name].apply(
                Q,
                [this].concat(array_slice(arguments))
            );
        };
    },
    void 0
);

makePromise.prototype.toSource = function () {
    return this.toString();
};

makePromise.prototype.toString = function () {
    return "[object Promise]";
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it�s a fulfilled promise, the fulfillment value is nearer.
 * If it�s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */
Q.nearer = valueOf;
function valueOf(value) {
    if (isPromise(value)) {
        return value.valueOf();
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object && typeof object.promiseDispatch === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return object && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return !isFulfilled(object) && !isRejected(object);
}

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromiseAlike(valueOf(object));
}

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    object = valueOf(object);
    return isPromise(object) && "exception" in object;
}

var rejections = [];
var errors = [];
var errorsDisplayed;
function displayErrors() {
    if (
        !errorsDisplayed &&
        typeof window !== "undefined" &&
        !window.Touch &&
        window.console
    ) {
        // This promise library consumes exceptions thrown in handlers so
        // they can be handled by a subsequent promise.  The rejected
        // promises get added to this array when they are created, and
        // removed when they are handled.
        console.log("Should be empty:", errors);
    }
    errorsDisplayed = true;
}

// Show unhandled rejection if Node exits without handling an outstanding
// rejection.  (Note that Browserify presently produces a process global
// without the Emitter on interface)
if (typeof process !== "undefined" && process.on) {
    process.on("exit", function () {
        for (var i = 0; i < errors.length; i++) {
            var error = errors[i];
            if (error && typeof error.stack !== "undefined") {
                console.warn("Unhandled rejected promise:", error.stack);
            } else {
                console.warn("Unhandled rejected promise (no stack):", error);
            }
        }
    });
}

/**
 * Constructs a rejected promise.
 * @param exception value describing the failure
 */
Q.reject = reject;
function reject(exception) {
    var rejection = makePromise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                var at = array_indexOf(rejections, this);
                if (at !== -1) {
                    errors.splice(at, 1);
                    rejections.splice(at, 1);
                }
            }
            return rejected ? rejected(exception) : this;
        }
    }, function fallback() {
        return reject(exception);
    }, function valueOf() {
        return this;
    }, exception, true);
    // note that the error has not been handled
    displayErrors();
    rejections.push(rejection);
    errors.push(exception);
    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(object) {
    return makePromise({
        "when": function () {
            return object;
        },
        "get": function (name) {
            return object[name];
        },
        "set": function (name, value) {
            object[name] = value;
        },
        "delete": function (name) {
            delete object[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return object.apply(void 0, args);
            } else {
                return object[name].apply(object, args);
            }
        },
        "apply": function (thisP, args) {
            return object.apply(thisP, args);
        },
        "keys": function () {
            return object_keys(object);
        }
    }, void 0, function valueOf() {
        return object;
    });
}

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
Q.resolve = resolve;
function resolve(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }
    // In order to break infinite recursion or loops between `then` and
    // `resolve`, it is necessary to attempt to extract fulfilled values
    // out of foreign promise implementations before attempting to wrap
    // them as unresolved promises.  It is my hope that other
    // implementations will implement `valueOf` to synchronously extract
    // the fulfillment value from their fulfilled promises.  If the
    // other promise library does not implement `valueOf`, the
    // implementations on primordial prototypes are harmless.
    value = valueOf(value);
    // assimilate thenables, CommonJS/Promises/A+
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return makePromise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return valueOf(object);
    });
}

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, resolvedValue);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    var resolvedValue = resolve(value);
    nextTick(function () {
        resolvedValue.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    resolvedValue.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(promise, fulfilled, rejected) {
    return when(promise, function (valuesOrPromises) {
        return all(valuesOrPromises).then(function (values) {
            return fulfilled.apply(void 0, values);
        }, rejected);
    }, rejected);
}

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  This presently only works in
 * Firefox/Spidermonkey, however, this code does not cause syntax
 * errors in older engines.  This code should continue to work and
 * will in fact improve over time as the language improves.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 *  - in present implementations of generators, when a generator
 *    function is complete, it throws ``StopIteration``, ``return`` is
 *    a syntax error in the presence of ``yield``, so there is no
 *    observable return value. There is a proposal[1] to add support
 *    for ``return``, which would permit the value to be carried by a
 *    ``StopIteration`` instance, in which case it would fulfill the
 *    promise returned by the asynchronous generator.  This can be
 *    emulated today by throwing StopIteration explicitly with a value
 *    property.
 *
 *  [1]: http://wiki.ecmascript.org/doku.php?id=strawman:async_functions#reference_implementation
 *
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            try {
                result = generator[verb](arg);
            } catch (exception) {
                if (isStopIteration(exception)) {
                    return exception.value;
                } else {
                    return reject(exception);
                }
            }
            return when(result, callback, errback);
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "send");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 * Only useful presently in Firefox/SpiderMonkey since generators are
 * implemented.
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are resolved and passed as values (`this` is also resolved and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q.resolve(a), Q.resolve(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    var deferred = defer();
    nextTick(function () {
        resolve(object).promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
}

/**
 * Constructs a promise method that can be used to safely observe resolution of
 * a promise for an arbitrarily named method like "propfind" in a future turn.
 *
 * "dispatcher" constructs methods like "get(promise, name)" and "put(promise)".
 */
Q.dispatcher = dispatcher;
function dispatcher(op) {
    return function (object) {
        var args = array_slice(arguments, 1);
        return dispatch(object, op, args);
    };
}

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = dispatcher("get");

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = dispatcher("set");

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q["delete"] = // XXX experimental
Q.del = dispatcher("delete");

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
var post = Q.post = dispatcher("post");

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = send;
Q.invoke = send; // synonyms
function send(value, name) {
    var args = array_slice(arguments, 2);
    return post(value, name, args);
}

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = fapply;
function fapply(value, args) {
    return dispatch(value, "apply", [void 0, args]);
}

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] = fcall; // XXX experimental
Q.fcall = fcall;
function fcall(value) {
    var args = array_slice(arguments, 1);
    return fapply(value, args);
}

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = fbind;
function fbind(value) {
    var args = array_slice(arguments, 1);
    return function fbound() {
        var allArgs = args.concat(array_slice(arguments));
        return dispatch(value, "apply", [this, allArgs]);
    };
}

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually resolved object
 */
Q.keys = dispatcher("keys");

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            if (isFulfilled(promise)) {
                promises[index] = valueOf(promise);
            } else {
                ++countDown;
                when(promise, function (value) {
                    promises[index] = value;
                    if (--countDown === 0) {
                        deferred.resolve(promises);
                    }
                }, deferred.reject);
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

/**
 * Waits for all promises to be resolved, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = allResolved;
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, resolve);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q["catch"] = // XXX experimental
Q.fail = fail;
function fail(promise, rejected) {
    return when(promise, void 0, rejected);
}

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(promise, progressed) {
    return when(promise, void 0, void 0, progressed);
}

/**
 * Provides an opportunity to observe the rejection of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q["finally"] = // XXX experimental
Q.fin = fin;
function fin(promise, callback) {
    return when(promise, function (value) {
        return when(callback(), function () {
            return value;
        });
    }, function (exception) {
        return when(callback(), function () {
            return reject(exception);
        });
    });
}

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = done;
function done(promise, fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);

            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promiseToHandle = fulfilled || rejected || progress ?
        when(promise, fulfilled, rejected, progress) :
        promise;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }
    fail(promiseToHandle, onUnhandledError);
}

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = timeout;
function timeout(promise, ms) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error("Timed out after " + ms + " ms"));
    }, ms);

    when(promise, function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
}

/**
 * Returns a promise for the given value (or promised value) after some
 * milliseconds.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after some
 * time has elapsed.
 */
Q.delay = delay;
function delay(promise, timeout) {
    if (timeout === void 0) {
        timeout = promise;
        promise = void 0;
    }

    var deferred = defer();

    when(promise, undefined, undefined, deferred.notify);
    setTimeout(function () {
        deferred.resolve(promise);
    }, timeout);

    return deferred.promise;
}

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = nfapply;
function nfapply(callback, args) {
    var nodeArgs = array_slice(args);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    fapply(callback, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 *
 *      Q.nfcall(FS.readFile, __filename)
 *      .then(function (content) {
 *      })
 *
 */
Q.nfcall = nfcall;
function nfcall(callback/*, ...args */) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    fapply(callback, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 *
 *      Q.nfbind(FS.readFile, __filename)("utf-8")
 *      .then(console.log)
 *      .done()
 *
 */
Q.nfbind = nfbind;
Q.denodeify = Q.nfbind; // synonyms
function nfbind(callback/*, ...args */) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());

        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
}

Q.nbind = nbind;
function nbind(callback, thisArg /*, ... args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());

        function bound() {
            return callback.apply(thisArg, arguments);
        }

        fapply(bound, nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
}

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.npost = npost;
function npost(object, name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    post(object, name, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = nsend;
Q.ninvoke = Q.nsend; // synonyms
function nsend(object, name /*, ...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    post(object, name, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

Q.nodeify = nodeify;
function nodeify(promise, nodeback) {
    if (nodeback) {
        promise.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return promise;
    }
}

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});
(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,h=e.reduce,v=e.reduceRight,d=e.filter,g=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,_=Object.keys,j=i.bind,w=function(n){return n instanceof w?n:this instanceof w?(this._wrapped=n,void 0):new w(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=w),exports._=w):n._=w,w.VERSION="1.4.4";var A=w.each=w.forEach=function(n,t,e){if(null!=n)if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a in n)if(w.has(n,a)&&t.call(e,n[a],a,n)===r)return};w.map=w.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e[e.length]=t.call(r,n,u,i)}),e)};var O="Reduce of empty array with no initial value";w.reduce=w.foldl=w.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduce===h)return e&&(t=w.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(O);return r},w.reduceRight=w.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduceRight===v)return e&&(t=w.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=w.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(O);return r},w.find=w.detect=function(n,t,r){var e;return E(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},w.filter=w.select=function(n,t,r){var e=[];return null==n?e:d&&n.filter===d?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&(e[e.length]=n)}),e)},w.reject=function(n,t,r){return w.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},w.every=w.all=function(n,t,e){t||(t=w.identity);var u=!0;return null==n?u:g&&n.every===g?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var E=w.some=w.any=function(n,t,e){t||(t=w.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};w.contains=w.include=function(n,t){return null==n?!1:y&&n.indexOf===y?n.indexOf(t)!=-1:E(n,function(n){return n===t})},w.invoke=function(n,t){var r=o.call(arguments,2),e=w.isFunction(t);return w.map(n,function(n){return(e?t:n[t]).apply(n,r)})},w.pluck=function(n,t){return w.map(n,function(n){return n[t]})},w.where=function(n,t,r){return w.isEmpty(t)?r?null:[]:w[r?"find":"filter"](n,function(n){for(var r in t)if(t[r]!==n[r])return!1;return!0})},w.findWhere=function(n,t){return w.where(n,t,!0)},w.max=function(n,t,r){if(!t&&w.isArray(n)&&n[0]===+n[0]&&65535>n.length)return Math.max.apply(Math,n);if(!t&&w.isEmpty(n))return-1/0;var e={computed:-1/0,value:-1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a>=e.computed&&(e={value:n,computed:a})}),e.value},w.min=function(n,t,r){if(!t&&w.isArray(n)&&n[0]===+n[0]&&65535>n.length)return Math.min.apply(Math,n);if(!t&&w.isEmpty(n))return 1/0;var e={computed:1/0,value:1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;e.computed>a&&(e={value:n,computed:a})}),e.value},w.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=w.random(r++),e[r-1]=e[t],e[t]=n}),e};var k=function(n){return w.isFunction(n)?n:function(t){return t[n]}};w.sortBy=function(n,t,r){var e=k(t);return w.pluck(w.map(n,function(n,t,u){return{value:n,index:t,criteria:e.call(r,n,t,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index<t.index?-1:1}),"value")};var F=function(n,t,r,e){var u={},i=k(t||w.identity);return A(n,function(t,a){var o=i.call(r,t,a,n);e(u,o,t)}),u};w.groupBy=function(n,t,r){return F(n,t,r,function(n,t,r){(w.has(n,t)?n[t]:n[t]=[]).push(r)})},w.countBy=function(n,t,r){return F(n,t,r,function(n,t){w.has(n,t)||(n[t]=0),n[t]++})},w.sortedIndex=function(n,t,r,e){r=null==r?w.identity:k(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;u>r.call(e,n[o])?i=o+1:a=o}return i},w.toArray=function(n){return n?w.isArray(n)?o.call(n):n.length===+n.length?w.map(n,w.identity):w.values(n):[]},w.size=function(n){return null==n?0:n.length===+n.length?n.length:w.keys(n).length},w.first=w.head=w.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:o.call(n,0,t)},w.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},w.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},w.rest=w.tail=w.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},w.compact=function(n){return w.filter(n,w.identity)};var R=function(n,t,r){return A(n,function(n){w.isArray(n)?t?a.apply(r,n):R(n,t,r):r.push(n)}),r};w.flatten=function(n,t){return R(n,t,[])},w.without=function(n){return w.difference(n,o.call(arguments,1))},w.uniq=w.unique=function(n,t,r,e){w.isFunction(t)&&(e=r,r=t,t=!1);var u=r?w.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:w.contains(a,r))||(a.push(r),i.push(n[e]))}),i},w.union=function(){return w.uniq(c.apply(e,arguments))},w.intersection=function(n){var t=o.call(arguments,1);return w.filter(w.uniq(n),function(n){return w.every(t,function(t){return w.indexOf(t,n)>=0})})},w.difference=function(n){var t=c.apply(e,o.call(arguments,1));return w.filter(n,function(n){return!w.contains(t,n)})},w.zip=function(){for(var n=o.call(arguments),t=w.max(w.pluck(n,"length")),r=Array(t),e=0;t>e;e++)r[e]=w.pluck(n,""+e);return r},w.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},w.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if("number"!=typeof r)return e=w.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},w.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},w.range=function(n,t,r){1>=arguments.length&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=Array(e);e>u;)i[u++]=n,n+=r;return i},w.bind=function(n,t){if(n.bind===j&&j)return j.apply(n,o.call(arguments,1));var r=o.call(arguments,2);return function(){return n.apply(t,r.concat(o.call(arguments)))}},w.partial=function(n){var t=o.call(arguments,1);return function(){return n.apply(this,t.concat(o.call(arguments)))}},w.bindAll=function(n){var t=o.call(arguments,1);return 0===t.length&&(t=w.functions(n)),A(t,function(t){n[t]=w.bind(n[t],n)}),n},w.memoize=function(n,t){var r={};return t||(t=w.identity),function(){var e=t.apply(this,arguments);return w.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},w.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},w.defer=function(n){return w.delay.apply(w,[n,1].concat(o.call(arguments,1)))},w.throttle=function(n,t){var r,e,u,i,a=0,o=function(){a=new Date,u=null,i=n.apply(r,e)};return function(){var c=new Date,l=t-(c-a);return r=this,e=arguments,0>=l?(clearTimeout(u),u=null,a=c,i=n.apply(r,e)):u||(u=setTimeout(o,l)),i}},w.debounce=function(n,t,r){var e,u;return function(){var i=this,a=arguments,o=function(){e=null,r||(u=n.apply(i,a))},c=r&&!e;return clearTimeout(e),e=setTimeout(o,t),c&&(u=n.apply(i,a)),u}},w.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},w.wrap=function(n,t){return function(){var r=[n];return a.apply(r,arguments),t.apply(this,r)}},w.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},w.after=function(n,t){return 0>=n?t():function(){return 1>--n?t.apply(this,arguments):void 0}},w.keys=_||function(n){if(n!==Object(n))throw new TypeError("Invalid object");var t=[];for(var r in n)w.has(n,r)&&(t[t.length]=r);return t},w.values=function(n){var t=[];for(var r in n)w.has(n,r)&&t.push(n[r]);return t},w.pairs=function(n){var t=[];for(var r in n)w.has(n,r)&&t.push([r,n[r]]);return t},w.invert=function(n){var t={};for(var r in n)w.has(n,r)&&(t[n[r]]=r);return t},w.functions=w.methods=function(n){var t=[];for(var r in n)w.isFunction(n[r])&&t.push(r);return t.sort()},w.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},w.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},w.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)w.contains(r,u)||(t[u]=n[u]);return t},w.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)null==n[r]&&(n[r]=t[r])}),n},w.clone=function(n){return w.isObject(n)?w.isArray(n)?n.slice():w.extend({},n):n},w.tap=function(n,t){return t(n),n};var I=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof w&&(n=n._wrapped),t instanceof w&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case"[object String]":return n==t+"";case"[object Number]":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case"[object Date]":case"[object Boolean]":return+n==+t;case"[object RegExp]":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if("object"!=typeof n||"object"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;r.push(n),e.push(t);var a=0,o=!0;if("[object Array]"==u){if(a=n.length,o=a==t.length)for(;a--&&(o=I(n[a],t[a],r,e)););}else{var c=n.constructor,f=t.constructor;if(c!==f&&!(w.isFunction(c)&&c instanceof c&&w.isFunction(f)&&f instanceof f))return!1;for(var s in n)if(w.has(n,s)&&(a++,!(o=w.has(t,s)&&I(n[s],t[s],r,e))))break;if(o){for(s in t)if(w.has(t,s)&&!a--)break;o=!a}}return r.pop(),e.pop(),o};w.isEqual=function(n,t){return I(n,t,[],[])},w.isEmpty=function(n){if(null==n)return!0;if(w.isArray(n)||w.isString(n))return 0===n.length;for(var t in n)if(w.has(n,t))return!1;return!0},w.isElement=function(n){return!(!n||1!==n.nodeType)},w.isArray=x||function(n){return"[object Array]"==l.call(n)},w.isObject=function(n){return n===Object(n)},A(["Arguments","Function","String","Number","Date","RegExp"],function(n){w["is"+n]=function(t){return l.call(t)=="[object "+n+"]"}}),w.isArguments(arguments)||(w.isArguments=function(n){return!(!n||!w.has(n,"callee"))}),"function"!=typeof/./&&(w.isFunction=function(n){return"function"==typeof n}),w.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},w.isNaN=function(n){return w.isNumber(n)&&n!=+n},w.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"==l.call(n)},w.isNull=function(n){return null===n},w.isUndefined=function(n){return n===void 0},w.has=function(n,t){return f.call(n,t)},w.noConflict=function(){return n._=t,this},w.identity=function(n){return n},w.times=function(n,t,r){for(var e=Array(n),u=0;n>u;u++)e[u]=t.call(r,u);return e},w.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))};var M={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};M.unescape=w.invert(M.escape);var S={escape:RegExp("["+w.keys(M.escape).join("")+"]","g"),unescape:RegExp("("+w.keys(M.unescape).join("|")+")","g")};w.each(["escape","unescape"],function(n){w[n]=function(t){return null==t?"":(""+t).replace(S[n],function(t){return M[n][t]})}}),w.result=function(n,t){if(null==n)return null;var r=n[t];return w.isFunction(r)?r.call(n):r},w.mixin=function(n){A(w.functions(n),function(t){var r=w[t]=n[t];w.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),D.call(this,r.apply(w,n))}})};var N=0;w.uniqueId=function(n){var t=++N+"";return n?n+t:t},w.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var T=/(.)^/,q={"'":"'","\\":"\\","\r":"r","\n":"n","    ":"t","\u2028":"u2028","\u2029":"u2029"},B=/\\|'|\r|\n|\t|\u2028|\u2029/g;w.template=function(n,t,r){var e;r=w.defaults({},r,w.templateSettings);var u=RegExp([(r.escape||T).source,(r.interpolate||T).source,(r.evaluate||T).source].join("|")+"|$","g"),i=0,a="__p+='";n.replace(u,function(t,r,e,u,o){return a+=n.slice(i,o).replace(B,function(n){return"\\"+q[n]}),r&&(a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'"),e&&(a+="'+\n((__t=("+e+"))==null?'':__t)+\n'"),u&&(a+="';\n"+u+"\n__p+='"),i=o+t.length,t}),a+="';\n",r.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{e=Function(r.variable||"obj","_",a)}catch(o){throw o.source=a,o}if(t)return e(t,w);var c=function(n){return e.call(this,n,w)};return c.source="function("+(r.variable||"obj")+"){\n"+a+"}",c},w.chain=function(n){return w(n).chain()};var D=function(n){return this._chain?w(n).chain():n};w.mixin(w),A(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=e[n];w.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!=n&&"splice"!=n||0!==r.length||delete r[0],D.call(this,r)}}),A(["concat","join","slice"],function(n){var t=e[n];w.prototype[n]=function(){return D.call(this,t.apply(this._wrapped,arguments))}}),w.extend(w.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);
define("lib/underscore", (function (global) {
    return function () {
        var ret, fn;
        return ret || global._;
    };
}(this)));

/*
    json2.js
    2013-05-26

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function () {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
define("lib/json2", function(){});

/**
 * An API Library for making JSON P calls without jQuery.
 * @author Christopher Pryce<cpryce@digitalriver.com>
 * 
 * Based on JSON and JSONP By Angus Croll
 * http://javascriptweblog.wordpress.com/2010/11/29/json-and-jsonp/
 * 
 * Copyright 2013 Digital River, Inc.
 *
 * Module definition
 * @dependency Q or an other library that supports CommonJS Promises/A API
 * @dependency underscore The underscore library, or another library that provides
 * a shim to map and forEach for supporting browsers still using ECMA 3.
 * 
 * jslint browser: true, nomen: true, sloppy: true 
 * using sloppy here for performance, but strict practices apply
 * 
 */
define('util/jsonp',['lib/q', 'lib/underscore', 'lib/json2'], function(promisesLib, _, JSON) {
    var jsonp, JsonpError = function(name, message, options) {
        this.name = name;
        this.message = message;
        this.value = options;
        this.toString = function() {
            return this.name + ": " + this.message + " " + options.join(",");
        };
    };

    jsonp = {
        // to provide unique callback identifiers
        callbackCounter: 0,

        /**
         * GETS JSON string from a remote URL
         * @param {String} uri The url of the call
         * @param {String} method One of either post, get, put or delete. This is sent to 
         *      API server as a string value.
         * @param {Object} urlParams An object to be encoded on the URL 
         */
        getJSON: function(uri, method, urlParams) {
            var defer = promisesLib.defer(),
                self = this,
                fnName,
                qstringParams = [],
                scriptTag,
                script;

            // encode the URL parameters
            qstringParams = _.map(urlParams, function(v, k) {
                return encodeURIComponent(k) + '=' + encodeURIComponent(v);
            });

            // create a temporary global function with a incremental key.
            // keeps duplicate functions from being created. 
            fnName = 'JSONPCallback_' + self.callbackCounter;
            self.callbackCounter += 1;

            window[fnName] = self.evalJSONP(defer);

            qstringParams.push('callback=' + fnName);
            qstringParams.push('format=json');
            qstringParams.push('dt=' + new Date().getTime()); // cache busting for GET request

            if (method) {
                method = method.toLowerCase();
            }
            qstringParams.push('method=' + method || 'get');

            uri += (uri.indexOf('?') === -1) ? '?' + qstringParams.join('&') : '&' + qstringParams.join('&');

            // append a script element to the document.
            scriptTag = document.createElement('SCRIPT');
            scriptTag.src = uri;
            script = document.getElementsByTagName('HEAD')[0].appendChild(scriptTag);

            // to handle scripts that return 201 or 204 and don't have a payload
            script.onload = script.onreadystatechange = function() {
                if ((!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
                    // wait briefly then if the promise is still pending, fulfill it with a simple json payload
                    setTimeout(function() {
                        if (defer.promise.isPending() && window[fnName]) {
                            window[fnName]({"success" : true});
                        }
                    }, 10);
                    // for a memory leak in ie6
                    script.onload = script.onreadystatechange = null;
                }
            };

            script.onerror = function () {
                setTimeout(function() {
                    if (defer.promise.isPending() && window[fnName]) {
                        defer.reject(new JsonpError("Server Error", "", qstringParams));
                    }
                }, 10);
            };

            // clean up global function and remove script after the function runs.
            return defer.promise.then(function(data) {
                window[fnName] = undefined;
                try {
                    delete window[fnName];
                } catch (ignore) {
                    // ignore error
                }

                try {
                    script.parentNode.removeChild(script);
                } catch (ignore) {
                    // ignore error
                }

                // chain the promise
                return data;
            }, function(err) {
                window[fnName] = undefined;
                try {
                    delete window[fnName];
                } catch (ignore) {
                    // ignore error
                }

                try {
                    script.parentNode.removeChild(script);
                } catch (ignore) {
                    // ignore error
                }
                throw err;
            });
        },
        /**
         * Evaluates the JSON object returned from the getJSON call
         * Resolves the passed promise.
         * @param {Promise} defer A CommonJS Promise/A API promise Object
         */
        evalJSONP: function(promise) {
            // return a closure to run when the script is loaded
            return function(data) {
                var validJSON = false;
                if (typeof data === "string") {
                    try {
                        validJSON = JSON.parse(data);
                    } catch (ignore) {
                        // invalid JSON or JSON.parse is not supported.
                    }
                } else {
                    try {
                        validJSON = JSON.parse(JSON.stringify(data));
                    } catch (e) {
                        validJSON = data;
                    }
                }

                if (validJSON) {
                    promise.resolve(validJSON);
                } else {
                    promise.reject("JSONP call returned invalid or empty JSON");
                }
            };
        }
    };
    return jsonp;
});

define('connection/Connection',['util/jsonp'], function(JSONP) {
    
    /**
     * This object is for the Apigee connection. It will provide
     * CRUD calls for the resources required 
     */
    var Connection = function() {};

    Connection.prototype = {
        create : function(uri, urlParams, headerParams, body) {
            return this.request(uri, 'POST', urlParams, headerParams, body);
        },

        retrieve : function(uri, urlParams, headerParams, body) {
            return this.request(uri, 'GET', urlParams, headerParams, body);
        },

        update : function(uri, urlParams, headerParams) {
            return this.request(uri, 'PUT', urlParams, headerParams);
        },

        remove : function(uri, urlParams, headerParams) {
            return this.request(uri, 'DELETE', urlParams, headerParams);
        },

        submitForm : function(uri, fields, headers) {
            headers = headers || {};
            headers["Content-Type"] = "application/x-www-form-urlencoded";
            return this.request(uri, "POST", {}, headers, fields);
        },

        request : function(uri, method, urlParams) {
            // ignores headerParams
            return JSONP.getJSON(uri, method, urlParams);
        }
    };
    return Connection;
});
/*jslint eqeq: true, nomen: true */
define('connection/Session',['config', 'connection/Connection', 'lib/q'], function(config, Connection, Q) {
    
    /**
     * This object is for getting a Session for connecting
     * @returns {Session}
     */
    var Session = function(apikey) {
        var self = this;

        self.apiKey = apikey;
        self._connection = new Connection();
        self.reset();
    };

    Session.prototype = {
        getAccess: function(access_type) {
            if (!access_type || access_type !== "authenticated") {
                return this.getLimitedAccess();
            }
        },

        getLimitedAccess : function() {
            var self = this,
                access_token = self.getAccessToken(),
                defer;

            // do we have an access token?
            if (access_token) {
                // if yes, is it valid? 
                if (self.isTokenTimeStampValid()) {
                    // if yes wrap it in a promise and return it.
                    defer = Q(access_token);
                } else {
                    // Get a new anonymous token using the shopper content element.
                    // Provides refresh.
                    defer = self.anonymousLogin();
                }
            } else {
                // if we do not have a token, return the promise to get one.
                defer = self.anonymousLogin();
            }

            return defer;
        },

        isTokenTimeStampValid : function() {
            var self = this,
                dt = new Date().getTime();

            return (self.tokenExpirationTime && self.tokenExpirationTime > dt);
        },
        // for now, since JSON P support for refresh token does not 
        // exist, get a new token
        doRefreshToken : function(promise) {
            return this.anonymousLogin(promise);
        },

        anonymousLogin: function(promise) {
            var self = this,
                d = new Date(),
                uri = config.getTokenServiceUri();

            if (self.pendingRequest == null) {
                self.pendingRequest = self._connection.request(uri, 'GET').then(function(sessionData) {
                    var tokenOptions = {
                        "ts" : d.getTime(),
                        "apiKey" : self.apiKey
                    };
                    // if there is session cookies, use them. If not, use the shopDomain
                    if (sessionData.stickyParameters === null || sessionData.stickyParameters === "") {
                        tokenOptions.domain = sessionData.shopDomain;
                    } else {
                        tokenOptions.cookie = sessionData.stickyParameters;
                    }
                    return self.getAnnonymousAccessToken(tokenOptions);
                });
            }
            return self.pendingRequest;
        },

        getAnnonymousAccessToken : function (urlParams, promise) {
            var self = this,
                uri = config.getAnonymousLoginUri();

            return self._connection.request(uri, 'GET', urlParams)
                .then(function(data) {
                    self.connected = true;
                    self.setAccessToken(data.access_token);
                    self.setRefreshToken(data.refresh_token);
                    self.tokenStartTime = new Date().getTime();
                    self.tokenExpirationTime = new Date().getTime() + parseInt(data.expires_in * 1000, 10);

                    if (promise && typeof promise.resolve === 'function') {
                        promise.resolve(data.access_token);
                    }
                    self.pendingRequest = null;
                    return data.access_token;
                }).fail(function(errorStr) {
                    // If fails cleans the refresh_token to obtain a new one on the next anonymousLogin call
                    if (promise && typeof promise.reject === 'function') {
                        promise.reject(errorStr);
                    }
                    self.reset();
                    self.pendingRequest = null;
                });
        },

        reset : function() {
            var self = this;
            self.setAccessToken(null);
            self.setRefreshToken(null);
            self.connected = false;
            self.tokenStartTime = null;
            self.tokenExpirationTime = null;
        },

        getAccessToken : function() {
            return this._token;
        },

        setAccessToken : function(t) {
            this._token = t;
        },

        getRefreshToken: function() {
            return this._refreshToken;
        },

        setRefreshToken: function(rt) {
            this._refreshToken = rt;
        }
    };

    return Session;
});

define('service/BaseService',['util/Class', 'connection/Connection'], function(Class, Connection) {
    var BaseService = Class.extend({
        init: function(client) {
            var self = this;
            self._client = client;
            self._connection = new Connection();
        },

        list : function(uri, params) {
            var self = this;
            uri = uri || self.uri;

            return self._client.connect()
                .then(function(access_token) {
                    var urlParams = self._makeQueryParams({token: access_token}, params);
                    return self._connection.request(uri, 'GET', urlParams);
                });
        },

        get : function(id, params) {
            var self = this,
                uri = [self.uri, id].join("/");

            return self._client.connect()
                .then(function(access_token){
                    var urlParams = self._makeQueryParams({token: access_token}, params);
                    return self._connection.request(uri, 'GET', urlParams);
                });
        },

        post: function(uri, params) {
            var self = this;
            uri = uri || self.uri;

            return self._client.connect()
                .then(function(access_token) {
                    var urlParams = self._makeQueryParams({token: access_token}, params);
                    return self._connection.request(uri, 'POST', urlParams);
                });
        },

        remove : function(uri, params) {
            var self = this;
            uri = uri || self.uri;

            return self._client.connect()
                .then(function(access_token) {
                    var urlParams = self._makeQueryParams({token: access_token}, params);
                    return self._connection.request(uri, 'DELETE', urlParams);                    
                });
        },

        _makeQueryParams : function(o, params) {
            for (var p in params) {
                if (params.hasOwnProperty(p)) {
                    o[p] = params[p];
                }
            }
            return o;
        }
    });
    return BaseService;
});

define('service/Shopper',['util/Class', 'service/BaseService', 'config'], function(Class, BaseService, config) {
    // private variable to store a shopper
    var theShopper = {
        currency: null,
        locale: null
    }; 

    return BaseService.extend({
        init: function() {
            var self = this;
            self._super.apply(this, arguments);
            self.uri = config.getShopperUrl();
        },
        // overrides the base method
        list : function() {
            var self = this;
            return self._super.apply(self, [self.uri, {expand: 'currency,locale'}]);
        },

        updateShopper : function(options) {
            var self = this,
                url = config.getShopperUrl();

            if (options == null) {
                options = {};
            }

            // fill in default values
            options.currency = options.currency || config.getDefaultCurrency();
            options.locale = options.locale || config.getDefaultLocale();

            return self.post(url, options).then(function(result) {
                if (result.success) {
                    theShopper.currency = options.currency;
                    theShopper.locale = options.locale;
                }
                return theShopper;
            });
        }
    });
});

define('api/Client',['util/Class', 'connection/Session', 'service/Shopper'], function(Class, Session, ShopperService) {
    return Class.extend({
        // the constructor function
        init: function(apiKey) {
            var self = this;
            self._session = new Session(apiKey);
            self.shopperService = new ShopperService(self);
        },

        connect: function() {
            var self = this, 
                s = self._session;

            $(self).trigger('drconnect-beforeconnect', [self]);
            return s.getAccess();
        },

        disconnect : function() {
            this._session.reset();
        },

        getSession : function() {
            return this._session;
        },
        // convenience method; passes through to the shopper service
        updateShopper : function(options) {
            return this.shopperService.updateShopper(options).then(function(shopper) {
                return shopper;
            }, function() {
                // handle errors 
            });
        }
    });
});

/**
 * General functions required on the library
 */
define('util/util',[], function() {
    var result = {};
    result.namespace = function(namespaceString) {
        var parts = namespaceString.split('.'),
            parent = window,
            currentPart = '';    
    
        for(var i = 0, length = parts.length; i < length; i++) {
            currentPart = parts[i];
            parent[currentPart] = parent[currentPart] || {};
            parent = parent[currentPart];
        }
    
        return parent;
    };
    result.is_array = function(input){
        return typeof(input)=='object'&&(input instanceof Array);
    }
    result.is_string = function(input){
        return typeof(input)=='string';
    }
    
    result.getAttribute = function(object, attribute) {
        var parts = attribute.split('.'),
        parent = object,
        currentPart = '';   
        for(var i = 0, length = parts.length; i < length; i++) {
            currentPart = parts[i];
            parent[currentPart] = parent[currentPart] || {};
            parent = parent[currentPart];
        }
    
        return parent;        
    }
    
    result.setAttribute = function(object, attribute, value) {
        var parts = attribute.split('.'),
        parent = object,
        currentPart = '';   
        for(var i = 0, length = parts.length; i < length - 1; i++) {
            currentPart = parts[i];
            parent[currentPart] = parent[currentPart] || {};
            parent = parent[currentPart];
        }
        parent[parts[length-1]] = value;
    }
    result.merge = function(object1, object2) {
        for (var name in object2) {
            object1[name] = object2[name];
        }
        return object1;
    }
    
    result.isAbsoluteUri = function(uri) {
        return (uri.lastIndexOf("http", 0) === 0);
    }
    
    result.Error = function(message) {
        this.message = message;
    };
    
    result.getQueryStringParam = function(url, name) {
        var results = new RegExp('[\\?&]' + name + '=([^&#]*)').exec(url);
        if (!results) { 
            return ""; 
        }
        return results[1] || 0;
    }
    
    result.getCurrentPath = function() {
        var url = window.location.href.replace(window.location.hash, "");
        return url.substring(0, url.lastIndexOf("/"));
    }
    
    return result;
});
define('service/Cart',['util/Class', 'service/BaseService', 'config', 'lib/q', 'util/util'], function(Class, BaseService, config, Q, utils) {
    var emptyOfferCache = null; // cache the empty offers.

    var CartService = BaseService.extend({
        init: function(client) {
            var self = this;
            self._super.apply(self, arguments);
            self.uri = config.getCartResourceUrl();
        },

        getActiveCart : function() {
            var self = this;
            return this.list(config.getCartResourceUrl(), {
                expand:'all,pricing.all,lineitems.lineitem.product,lineitems.lineitem.pricing.all,shippingOptions,shippingMethods'
            }).then(function(data) {
                return data.cart;
            });
        },

        getEmptyCartOffer : function() {
            var self = this;
            if (emptyOfferCache === null && config.getEmptyOfferUrl() != null) {
                defer = this.list(config.getEmptyOfferUrl(), {expand: 'productOffers.productOffer.addProductToCart'}).then(function(data) {
                    emptyOfferCache = data.offer;
                    return emptyOfferCache;
                }, function() {
                    // TODO Error handling.
                    defer = null;
                });
            } else {
                defer = Q(emptyOfferCache);
            }
            return defer;
        },

        applyCouponCode : function(v) {
            var self = this;
            if ($(self).triggerHandler('drconnect-beforeapplycode', [v]) !== false) {
                return self.post(null, {promoCode: v}).then(function(result){
                    return self.getActiveCart();
                }, function() {
                    // For now, we will never reach this
                    return self.getActiveCart();
                });
            }
        },

        addLineItemToCart : function(uri) {
            var self = this,
                pid = utils.getQueryStringParam(uri, 'productId'),
                productUri = [config.getProductResourceURL(), pid].join("/");

            if ($(self).triggerHandler('drconnect-beforeaddproduct', [uri]) !== false) {
                return self.list(productUri).then(function(p) {
                    if (p.product && p.product.variations && p.product.variations.product) {
                        $(self).trigger('drconnect-carterror', ["Base  products can't be purchased."]);
                        throw "Cannot add product to cart.";
                    }

                    return self.post(uri).then(function(lineitem) {
                        return self.getActiveCart();
                    }, function(e) {
                        $(self).trigger('drconnect-carterror', [e]);
                        throw e;
                    });
                }, function(err) {
                    $(self).trigger('drconnect-carterror', [err]);
                    throw err;
                });
            }
        },
        // Because we can't rely on  IE to get an error for this activity we need to manually 
        // check to see if this can succeed.
        // TODO When API Support is available, need to enable add product by quantity
        addLineItemToCartById : function(id, qty, originalLink){
            var self = this,
                uri = [config.getProductResourceURL(), id].join("/");

            qty = qty || 1;
            if ($(self).triggerHandler('drconnect-beforeaddproduct', [uri]) !== false) {
                return self.list(uri).then(function(p) {
                    // if the product has variations, we can't purchase, throw an error.
                    if (p.product && p.product.variations && p.product.variations.product) {
                        return Q(originalLink);
                    }

                    return self.post(config.getLineItemUrl(), {productId: id, quantity: qty}).then(function(lineitem) {
                        return self.getActiveCart();
                    }, function(e) {
                        e.message = "Unable to Add Item to cart";
                        $(self).trigger('drconnect-carterror', [e]);
                        throw e;
                    });
                }, function(err) {
                    err.message = "Unable to Add Item to cart";
                    $(self).trigger('drconnect-carterror', [err]);
                    throw err;
                });
            }
        },

        updateQuantity : function(lineItemId, qty) {
            var self = this,
                uri = [config.getCartResourceUrl(), "line-items", lineItemId].join("/");

            // wrap this in a function to allow a listener to cancel this
            if ($(self).triggerHandler('drconnect-beforequantityupdate', [qty, lineItemId]) !== false) {
                return self.post(uri, {
                    "quantity" : qty, expand: 'all'
                }).then(function(lineItem) {
                    $(self).trigger('drconnect-quantityupdate',[qty, lineItemId]);
                    return self.getActiveCart();
                }, function(err) {
                    $(self).trigger('drconnect-carterror', [err]);
                    throw err;
                });
            }
        },

        removeLineItem : function(lineItemId) {
            var self = this,
                uri = [config.getCartResourceUrl(), 'line-items', lineItemId].join("/");

            if ($(self).triggerHandler('drconnect-beforeremoveitem',[lineItemId]) !== false) {
                return self.remove(uri).then(function() {
                    return self.getActiveCart();
                }, function(errstr) {
                    // TODO Error handling, update feedback, etc.
                    return self.getActiveCart();
                });
            }
        },

        getWebCheckoutUrl: function() {
            return this._client.connect().then(function(access_token){
                return config.getWebCheckoutUrl() + '?token=' + access_token + '&themeID=11156900';
            }, function() {
                return "Unable to checkout";
            });
        },

        clearCache : function(){ 
            emptyOfferCache = null;
        }
    });
    return CartService;
});

define('view/BaseView',['util/Class'], function(Class) {
    return Class.extend({
        init: function(options) {
            var self = this;
            self.setOptions(options);
            self.compileTemplates();
        },

        compileTemplates : function() {
            // Extend this function in implementing classes.
        },

        setOptions : function(o) {
            var self = this;
            self.options = $.extend({}, self.getDefaults(), o);
        },

        getOptions : function() {
            var self = this;
            return (self.options) ? self.options : {};
        },

        getOption : function(k) {
            var self = this;
            return self.options[k];
        },

        setOption : function(k, v) {
            var self = this;
            self.options[k] = v;
        },

        getDefaults : function() {
            return {};
        }
    });
});
define('view/CartView',['lib/underscore', 'view/BaseView'], function(_, BaseView) {
    var defaults = {
        summaryTemplate :
        '<div class="connect-cart-summary">' +
            '<h3><span>Shopping Cart</span> (<span class="connect-cart-quantity">0</span>)</h3>' +
        '</div>',

        cartTemplate : '<div id="drMiniCart" class="connect-mini-cart"></div>',

        cartHeaderTemplate:
        '<div class="connect-cart-header">' +
        '   <div class="connect-cart-feedback"></div>' +
        '   <div class="connect-cart-currency">' +
        '       <label for="drCartCurrencySelector">Currency:</label>'+
        '       <select id="drCartCurrencySelector" class="connect-cart-currencyselector">' +
        '       </select>' +
        '   </div>' +
        '</div>' +
        '<div class="connect-cart-offerheader"></div>',

        bodyTemplate :
        '<div class="connect-cart-body connect-loading">' +
        '   <div class="connect-cart-loadingmask">' +
        '      <span class="connect-spinner"></span>' +
        '   </div>' +
        '   <div class="connect-content">'+
        '       <%= emptyCartMessage %>' +
        '   </div>' +
        '</div>',

        emptyCartTemplate :
        '<p>Your Shopping Cart is empty.</p>',

        totalsTemplate :
        '<div class="connect-cart-totals">' +
        '   <div class="connect-cart-subtotal">' +
        '       <span>Subtotal:</span><span class="amount">0.00</span>' +
        '</div>' +
        '   <div class="connect-fine-print">' +
        '       <span>Excludes tax and shipping</span>' +
        '   </div>' +
        '</div>',

        couponTemplate :
        '<div class="connect-cart-couponwrapper connect-widget-button">' +
        '    <input id="couponCode" class="connect-widget-couponcode" type="text" value="" placeholder="Enter Coupon Code"/>' +
        '    <a class="connect-cart-applycoupon btn" disabled="disabled">' +
        '        <i class="icon-ok-sign"></i> Apply Code' +
        '    </a>' +
        '</div>',

        footerTemplate :
        '<div class="connect-cart-footer">' +
        '    <div class="connect-widget-link">' +
        '        <a href="#" class="connect-cart-showcode">Have a Promo Code?</a>' +
        '    </div>' +
        '    <div class="connect-widget-button right">' +
        '        <a href="#" class="connect-cart-checkout dr_button"><i class="icon-shopping-cart icon-white"></i> Checkout</a>' +
        '    </div>' +
        '    <div class="connect-widget-clearfix"></div>' +
        '</div>',

        // for empty cart merchandising
        offerHeaderTemplate :
        '<span><%= offerHeader %></span>',

        offerTemplate :
        '<div class="connect-cart-offer">' +
            '<p class="connect-cart-title"><%= product.displayName %></p>' +
            '<% if (pricing && (pricing.listPrice.value > pricing.salePriceWithQuantity.value)) { %>' +
            '<p><img class="connect-cart-image" src="<%= product.thumbnailImage %>" alt=""/>'+
            '<span class="connect-cart-pricing"><span>Regular Price: </span>' +
            '<span class="connect-widget-strikethrough"><del><%= pricing.formattedListPrice %></del></span></span>' +
            '<span class="connect-cart-pricing"><span>Promo Price: </span>' +
            '<span><%= pricing.formattedSalePriceWithQuantity %></span></span>' +
            '<%} else { %>'  +
            '<p><img class="connect-cart-image" src="<%= product.thumbnailImage %>" alt=""/>'+
            '<span class="connect-cart-pricing"><%= pricing.formattedSalePriceWithQuantity %></span>' +
            '<% } %>' +
            '<div class="connect-widget-button"><a class="connect-cart-buy" data-value="<%= addProductToCart.uri %>" href="<%= addProductToCart.uri %>">' +
            '<i class="icon-plus-sign"></i> Add</a></div>' +
            '</p><div style="line-height: 1; clear: both;"></div>' + 
        '</div>',

        productTemplate :
        '<div class="connect-cart-lineitem">' + 
            '<p class="connect-cart-title" title="<%= product.shortDescription %>"><%= product.displayName %></p>' +
            '<img src="<%= product.thumbnailImage %>"/>' + 
            '<div><span>Quantity: </span>' +
            '   <input autocomplete="off" type="text" class="connect-cart-quantity" data-lineitem-id="<%= id %>" value="<%= quantity %>"' +
            '<% if (product.inventoryStatus && product.inventoryStatus.maxOrderQuantity !== undefined){ %>' +
            ' data-maxorderquantity=<%=product.inventoryStatus.maxOrderQuantity%>' +
            '<%} %>' +
            '/>' +
            '   <a class="connect-cart-updatebtn btn" href="#"><i class="icon-refresh"></i></a>' +
            '</div>' +
            '<ul>' +
                '<li class="connect-cart-remove"><span><a href="#" data-lineitem-id="<%= id %>"><i class="icon-remove"></i> Remove</a></span></li>' +
                '<li class="connect-cart-sku"><span class="connect-cart-label">SKU: <%= product.sku %></span></li>' +
                '<li class="connect-cart-producttype">Product Type: <span><%= product.productType %></span></li>' +
                '<li class="connect-lineitem-pricing">' +
                    '<span class="connect-cart-label">Price: </span>' +
                    '<% if (pricing.listPriceWithQuantity.value > pricing.salePriceWithQuantity.value) { %> ' + 
                    '<span class="connect-widget-strikethrough"><%= pricing.formattedListPriceWithQuantity %>&nbsp;</span>' +
                    '<%}%>' +
                    '<span class="connect-lineitem-saleprice"><%= pricing.formattedSalePriceWithQuantity %></span>' +
                '</li>' +
            '</ul>' +
            '<div style="line-height: 1; clear: both;">&nbsp;</div>' + 
        '</div>',

        subtotalTemplate :
        '<% if (discount.value && discount.value > 0) { %>' +
        '<div class="connect-cart-orderdiscount">' +
            '<span>Discount: </span><span class="amount">-<%= formattedDiscount %></span>' +
        '</div> <%}%>' +
        '<% if (shippingAndHandling.value != null) { %>' +
        '<div class="connect-cart-orderdiscount">' +
            '<span>Estimated Shipping: </span><span class="amount"><%= formattedShippingAndHandling %></span>' +
        '</div> <%}%>' +
        '<div class="connect-cart-subtotal">' +
            '<span>Subtotal: </span><span class="amount"><%= formattedOrderTotal %></span>' +
        '</div>'+
        '<div class="connect-fine-print">' +
            '<span>Excludes tax</span>' +
        '</div>',

        feedbackTemplate :
        '<p><i class="icon-ok-sign"></i> <%= msg %></p>',

        errorTemplate: 
        '<p><i class="icon-warning-sign"></i> <%= msg %></p>',

        // the default cart element
        summaryElementSelector : '#drMiniCartSummary',

        // the default summary element
        cartElementSelector : '#drMiniCart',
        currency: ['USD'],
        defaultCurrency: 'USD'
    };

    // Utility Functions
    function createCartSummary() {
        var self = this,
            o = self.getOptions();

        // TODO if an summaryAnchorSelector is not provide, insert an element in the DOM
        $(o.summaryElementSelector).append(self.summaryTemplate());
    }
 
    // these templates are only used once so they are not compiled.
    function createCart() {
        var self = this,
            o = self.getOptions(),
            $cart = $('<div class="connect-cart-wrapper"></div>').appendTo(o['cartElementSelector']),
            headerTemplateHtml, bodyTemplateHtml, totalTemplateHtml, couponTemplateHtml, footerTemplateHtml, emptyCartHtml;

        // insert the header
        headerTemplateHtml = $('#drMiniCartHeaderTemplate');
        if (!headerTemplateHtml.length) {
            headerTemplateHtml = _.template(o.cartHeaderTemplate);
        }
        $cart.prepend(headerTemplateHtml);

        // add the currencies ... 
        _.each(o.currency, function(cv) {
            $option = $('<option value="' + cv + '">' + cv +'</option>');
            if (cv === o.defaultCurrency) {
                $option.attr("selected", "selected");
            }
            $cart.find('.connect-cart-currencyselector').append($option);
        });

        // insert the body
        bodyTemplateHtml = $('#drMiniCartBodyTemplate');
        if (!bodyTemplateHtml.length) {
           emptyCartHtml = o.emptyCartTemplate;
           bodyTemplateHtml = _.template(o.bodyTemplate, {emptyCartMessage: emptyCartHtml});
        }
        $cart.append(bodyTemplateHtml);

        // insert the totals
        totalTemplateHtml = $('#drMiniCartTotalTemplate');
        if (!totalTemplateHtml.length) {
            totalTemplateHtml = _.template(o.totalsTemplate);
        }
        $cart.append(totalTemplateHtml);

        // insert the coupon code block
        couponTemplateHtml = $('#drMiniCartTotalTemplate');
        if (!couponTemplateHtml.length) {
            couponTemplateHtml = _.template(o.couponTemplate);
        }
        $cart.append(couponTemplateHtml);

        // insert the footer
        footerTemplateHtml = $('#drMiniCartTotalTemplate');
        if (!footerTemplateHtml.length) {
            footerTemplateHtml = _.template(o.footerTemplate);
        }
        $cart.append(footerTemplateHtml);
    }

    // Main object
    return BaseView.extend({
        // @override - the constructor function
        init: function(options) {
            var self = this, $cart;

            self._super.apply(self, arguments);

            createCartSummary.call(self);
            createCart.call(self);

            $cart = $(self.getOption('cartElementSelector'));
            $cart.on('change', '.connect-cart-currencyselector', function() {
                var v = $(this).val();
                $(self).trigger('drconnect-changecurrency', [v]);
            });

            // set up the listener for have promo code link? 
            $cart.find('.connect-cart-showcode').on("click", function(evt){
                evt.preventDefault();
                $(this).hide();
                $cart.find('.connect-cart-couponwrapper').show().find('> input').select().focus();
            });

            // set up the listener for the coupon code input 
            $('#couponCode').on("keypress paste", function() {
                var $link = $(this);
                if ($link.val() !== '' || $link.val() != null) { // != for null or undefined
                    $link.parent('.connect-cart-couponwrapper').find('>a[class^="connect-"]').removeAttr('disabled');
                }
            });
        },
        // @override
        getDefaults : function() {
            return defaults;
        },
        // @override
        compileTemplates : function() {
            var self = this;
            self.summaryTemplate = _.template(self.getOption('summaryTemplate'));
            self.cartTemplate = _.template(self.getOption('cartTemplate'));
            self.cartOfferTemplate = _.template(self.getOption('offerTemplate'));
            self.offerHeaderTemplate = _.template(self.getOption('offerHeaderTemplate'));
            self.productTemplate = _.template(self.getOption('productTemplate'));
            self.subtotalTemplate = _.template(self.getOption('subtotalTemplate'));
            self.feedbackTemplate = _.template(self.getOption('feedbackTemplate'));
            self.errorTemplate = _.template(self.getOption('errorTemplate'));
            self.emptyCartTemplate = _.template(self.getOption('emptyCartTemplate'));
        },
        // @override 
        setOptions : function(options) {
            if (options.summaryElement) {
                options.summaryElementSelector = "#" + options.summaryElement;
            }

            if (options.cartElement) {
                options.cartElementSelector = "#" + options.cartElement;
            }
            this._super.apply(this, [options]);
        },

        setCartQuantity : function(qty) {
            var self = this,
                $el = $(self.getOption('summaryElementSelector'));

            if ($el.length) {
                $el.find('.connect-cart-quantity').empty().text(qty);
            }
        },
        /**
         * 
         * @param {Object} cartData
         * @param {Promise} emptyOffers
         * 
         */
        updateCart : function(cartData, emptyOffers) {
            var self = this,
                $cart = $(self.getOption('cartElementSelector'));

            // branch.. if cartData.lineItems && cartData.lineItems.lineItem.length ..
            // show line items 
            if (cartData.lineItems && cartData.lineItems.lineItem && cartData.lineItems.lineItem.length) {
                self.showLineItems($cart, cartData);
            } else {
                emptyOffers.then(function(offer) {
                    self.showEmptyCartOffers($cart, offer);
                });
            }
        },

        showLineItems : function($cart, cartData) {
            var self = this,
                items = [];

            $cart.find('.connect-cart-offerheader').hide().end()
                .find('.connect-cart-totals').show().end()
                .find('.connect-cart-footer').show()
                .find('.connect-cart-showcode').show();

            try {
                items = cartData.lineItems.lineItem || [];
            } catch (ignore) {
                // ignore lineItem not defined error
            }

            self.renderLineItems($cart, items);

            // add behaviors if this cart has not been initialized.
            self.setupEventListeners($cart);
            self.updateCartSubtotal(cartData);

            $(self).trigger('drconnect-updatecart', [cartData]);
        },

        renderLineItems : function($cart, lineItems) {
            var self = this,
                html = "";

            _.each(lineItems, function(lineItem) {
                var product, inventoryStatus, availableQuantity;
                if (lineItem && lineItem.product !== undefined && lineItem.product.inventoryStatus !== undefined) {
                    // make local references for speed/convenience
                    product = lineItem.product;
                    inventoryStatus = lineItem.product.inventoryStatus;

                    // cast available quantity to a number
                    availableQuantity = parseInt(inventoryStatus.availableQuantity, 10);
                    if (!isNaN(availableQuantity)) {
                        inventoryStatus.availableQuantity = availableQuantity;
                    }
                    // add a max order property: max order = inventory status available quantity - quantity.
                    // if the product defines a maxOrderQuantity, use that

                    if (product.maxOrderQuantity !== undefined) {
                        inventoryStatus.maxOrderQuantity = product.maxOrderQuantity;
                    } else {
                        // if product.maxOrderQuantity is not set, and prodcutIsAllowsBackorders is false, don't
                        // set a maxOrderValue. Else set it to availableQuantity - liteItem.quantity;
                        if (inventoryStatus.productIsAllowsBackorders === "false" || inventoryStatus.productIsAllowsBackorders === false) {
                            inventoryStatus.maxOrderQuantity = (availableQuantity - lineItem.quantity);
                        }
                    }
                    // allow setting the quantity to zero if minOrderQuantity is not set.
                    inventoryStatus.minOrderQuantity = product.minOrderQuantity || 0;
                } else {
                    // not sure what to do here ... feels like an error.
                }

                html += self.productTemplate(lineItem);
            });

            $cart.find('.connect-cart-body .connect-content').empty().html(html).end();
        },

        setupEventListeners : function($cart) {
            var self = this;

            if (!$cart.hasClass('initialized')) {
                $cart.addClass('initialized')
                    .on('keypress', 'input[type="text"]', function(evt) {
                        // listen for the enter key
                        if (evt.keyCode === 13) {
                            $(self).trigger("drconnect-updatequantity", [this.value, this]) ;
                        }
                        evt.stopImmediatePropagation(); // no other listeners fire
                    }).on('click', '.connect-cart-remove a', function(evt) {
                        evt.preventDefault();
                        $(self).trigger('drconnect-remove', [this]);
                    }).on("click", ".connect-cart-applycoupon", function() {
                        if (!$(this).attr('disabled') && !$(this).hasClass('disabled')) {
                            var field = $('#couponCode').get(0);
                            $(self).trigger('drconnect-applycoupon', [field, this]);
                        }
                        return false; // prevent default and stop propagation
                    }).on('click', '.connect-cart-buy', function(evt){
                        evt.preventDefault();
                        // normalize this behavior for buttons or a tag
                        var v = this.value || this.href;
                        $(self).trigger('drconnect-addtocart',[{value: v}, this]);
                    }).on("click", ".connect-cart-updatebtn", function() {
                        var $btn = $(this), $field;
                        if (!$btn.attr('disabled') && !$btn.hasClass('disabled') ){
                            $field = $btn.siblings('input[type="text"]');
                            if ($field.length && $field.val() > -1) {
                                $(self).trigger("drconnect-updatequantity", [$field.val(), $field.get(0)]) ;
                            }
                        }
                        return false;   // prevent default and stop propagation
                    });
            }
        },

        updateCartSubtotal : function(cartData) {
            var self = this, pricing = cartData.pricing;

            if (pricing && pricing.formattedOrderTotal != null) { // != null for null or undefined
                // fix an error in the data type
                if (pricing.discount && typeof pricing.discount.value === 'string') {
                    if (!isNaN(parseInt(pricing.discount.value, 10))) {
                        // cast value to a number
                        pricing.discount.value = parseInt(pricing.discount.value, 10);
                    }
                }
                if (pricing.shippingAndHandling && typeof pricing.shippingAndHandling.value === 'string') {
                    if (!isNaN(parseInt(pricing.shippingAndHandling.value, 10))) {
                        pricing.shippingAndHandling.value = parseInt(pricing.shippingAndHandling.value, 10);
                    }
                }
                $('#drMiniCart').find('.connect-cart-totals').empty().html(self.subtotalTemplate(pricing));
            } else {
                pricing = {formattedOrderTotal: "0.00", discount: {"value": 0}, shippingAndHandling: {"value": 0}};
                $('#drMiniCart').find('.connect-cart-totals').empty().html(self.subtotalTemplate(pricing));
            }
        },

        showEmptyCartOffers : function($cart, offer) {
            var self = this;

            self.renderEmptyOffers($cart, offer);

            $('#drMiniCart').find('.connect-cart-totals').hide().end()
                .find('.connect-cart-couponwrapper').hide().end()
                .find('.connect-cart-footer').hide();

            self.setupEventListeners($cart);
            $(self).trigger('drconnect-updatecart', [offer]);
        },

        renderEmptyOffers : function($cart, offer) {
            var self = this, html = '', offers = [], i, l;

            try {
                offers = offer.productOffers.productOffer;
            } catch (ignore) {
                // ignore error for productOffers or productOffer is undefined.
            }

            if (offers.length) {
                if (offer.salesPitch[0]) {
                    $('#drMiniCart').find('.connect-cart-offerheader').show()
                    .html(self.offerHeaderTemplate({offerHeader : offer.salesPitch[0]}));
                }

                for (i = 0, l = offers.length; i < l; i += 1) {
                    html += self.cartOfferTemplate(offers[i]);
                }
            } else {
                html = self.emptyCartTemplate();
            }

            $cart.find('.connect-cart-body .connect-content').empty().html(html).end();
        },

        hideCouponEntry : function() {
            var self = this, o = this.getOptions(), $cart;

            $cart = $(o.cartElementSelector);
            // hide the coupon input field
            $cart.find('.connect-cart-couponwrapper').hide()
                .find('>a[class^="connect-"]').attr('disabled', 'disabled');

            // show the Have a Promo Code ? link
            $cart.find('.connect-cart-showcode').show();
        },

        setCurrency : function(v) {
            var currencySelector = $('#drMiniCart').find('.connect-cart-currencyselector');
            currencySelector.val(v);
        },

        blockCartUI: function() {
            // disable all of the buttons in the mini-cart div.
            // disable the currency selector.
            // mask the cart by adding a class name
            $('#drMiniCart').find('.connect-cart-body').addClass('connect-loading').find('.connect-content').scrollTop(0);
        },

        unblockCartUI: function () {
            $('#drMiniCart').find('.connect-cart-body').removeClass('connect-loading').find('.connect-content').scrollTop(0);
        },

        showFeedback : function(msg, isError) {
            var self = this, html,
                $feedbackContainer = $('#drMiniCart').find('.connect-cart-feedback');

            // make sure that isError is set. 
            isError = !! isError;
            html = (isError ? self.errorTemplate({msg: msg}) : self.feedbackTemplate({msg: msg}));
            // clear the existing time out.
            if (self.feedbackTO !== null) {
                clearTimeout(self.feedbackTO);
                self.feedbackTO = null;

                // run the hide immediately to show the next message.
                self.hideFeedback(function() {
                     $feedbackContainer.toggleClass('connect-cart-error', isError).html(html).fadeIn();
                });
            } else {
                $feedbackContainer.toggleClass('connect-cart-error', isError).html(html).fadeIn();
            }
            // show the feedback div, set a time out to hide it.
            self.feedbackTO = setTimeout(function() {
                self.hideFeedback();
            }, 5000);
        },

        hideFeedback : function(callback) {
            $('#drMiniCart').find('.connect-cart-feedback').fadeOut(function() {
                if (typeof callback === "function") {
                    callback.call(this);
                }
            });
        }
    });
});

/*jslint browser: true, devel: false, nomen: true, sloppy: true, todo: true, indent: 4 */
/* Removing "use strict" but strict practices still apply */
define('minicart',[
        'api/Client',
        'config',
        'service/Cart',
        'view/CartView',
        'util/Class'
    ], function(Client, config, Cart, CartView, Class) {

    // TODO this should be a configuration option
    var anchorSelector = 'a[href*="AddItemToRequisition"],area[href*="AddItemToRequisition"],a[href*="/store/"][href*="/buy/"][href*="/productID."],area[href*="/store/"][href*="/buy/"][href*="/productID."]';

    // Re-write standard store buy links to change them to add-to-cart
    // config option hijackLinks (default true).
    function ajaxifyAddToCartLinks(cartView, cartService, context) {
        // Define the regular expression searches for the hyperlinks
        var productIdRegEx = /\/?ProductID[=\.](\d+)\/?/i,
            quantityRegEx = /\/?Quantity[=\.](\d+)\/?/i;

        if (context === undefined) {
            context = document;
        }

        // Check for add-to-cart links, anywhere on the page
        $(anchorSelector, context).each(function() {
            // Assume that the productID HAS to be in an add-to-cart link!
            var productId = this.href.match(productIdRegEx)[1],
                quantity = (quantityRegEx.test(this.href)) ? RegExp.$1 : '1';

            // Add the onclick event-handler
            $(this).on("click", function(evt) {
                var $btn = $(this);
                evt.preventDefault();

                $btn.addClass('disabled');
                cartService.addLineItemToCartById(productId, quantity, $btn.attr('href')).then(function(cartData) {
                    if (typeof cartData === "string") {
                        // we returned a url; follow it.
                        window.location.href = cartData;
                    } else {
                        cartView.setCartQuantity(cartData.totalItemsInCart);
                        cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                        $btn.removeClass('disabled');
                        cartView.showFeedback("Item added to cart.");
                    }
                }, function(err) {
                    $btn.removeClass('disabled');
                    cartView.showFeedback(err.message, true);
                });
            });
        });
    }

    return Class.extend({
        defaults: {
            summaryElement: 'drMiniCartSummary',
            cartElement: 'drMiniCart',
            rewriteLinks: true
        },

        init: function(options) {
            var self = this, cartService, cartView, o;
            // set the options and then get them right away. Defaults will be set.
            self.setOptions(options);
            o = self.getOptions();

            // TODO check to make sure that API key exists
            self.client = new Client(options.apiKey);

            // TODO make sure that client is constructed properly
            cartService = new Cart(self.client);
            cartView = new CartView(options);

            // re-write all of the buy now links.
            if (o.rewriteLinks !== false) {
                ajaxifyAddToCartLinks.call(self, cartView, cartService);
            }

            $(cartService).on('drconnect-beforeaddproduct drconnect-beforeremoveitem drconnect-beforequantityupdate drconnect-beforeapplycode', function() {
                cartView.blockCartUI();
            }).on('drconnect-carterror', function() {
                cartView.unblockCartUI();
            });

            // listeners for cart events.
            $(cartView).on('drconnect-addtocart', function(evt, btn) {
                // if the item cannot be added to the cart, follow the link
                cartService.addLineItemToCart(btn.value).then(function(cartData) {
                    cartView.showFeedback("Item added to cart.");
                    cartView.setCartQuantity(cartData.totalItemsInCart);
                    cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                }, function(err) {
                    cartView.showFeedback(err.message, true);
                });
            }).on('drconnect-updatequantity', function(evt, qty, field) {
                var lineItemId = $(field).attr('data-lineitem-id');
                // check that the qty != field.defaultValue
                // if qty === defaultValue it is no-op.
                if (qty !== field.defaultValue) {
                    // a quantity update
                    // make sure that the qty can be parsed as a number
                    if (!isNaN(qty - 0) && (qty -0) > 0){
                        if (lineItemId) {
                            cartService.updateQuantity(lineItemId, qty).then(function(cartData) {
                                cartView.showFeedback("Quantity Updated");
                                cartView.setCartQuantity(cartData.totalItemsInCart);
                                cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                            }, function(err) {
                                cartView.showFeedback("Unable to Update", true);
                                field.value = field.defaultValue;
                            });
                        }
                    } else {
                        cartView.showFeedback("Please enter a number greater than zero", true);
                        field.value = field.defaultValue;
                    }
                }
            }).on('drconnect-remove', function(evt, icon) {
                var lineItemId = $(icon).attr('data-lineitem-id');
                if (lineItemId) {
                    cartService.removeLineItem(lineItemId).then(function(cartData) {
                        cartView.showFeedback("Item removed");
                        cartView.setCartQuantity(cartData.totalItemsInCart);
                        cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                    });
                }
            }).on('drconnect-updatecart', function(evt, cartData) {
                this.unblockCartUI();
            }).on('drconnect-changecurrency', function(evt, c) {
                this.blockCartUI();
                self.client.updateShopper({currency: c}).then(function() {
                    // this returns 201 with no content
                    cartView.showFeedback("Currency Settings Updated");
                    return; // TODO maybe message shopper or log 
                }, function() {
                    cartView.showFeedback("Unable to update Currenct Settings", true);
                    return; // TODO maybe message shopper or log error
                }).done(function() {
                    cartService.clearCache();
                    cartService.getActiveCart().then(function(cartData) {
                        cartView.setCartQuantity(cartData.totalItemsInCart);
                        cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                    });
                });
            }).on('drconnect-applycoupon', function(evt, field, btn) {
                var v = $(field).val();
                if (v != null) {
                    cartService.applyCouponCode(v).then(function(cartData) {
                        cartView.showFeedback("Coupon code applied. Final price will be determined at checkout.");
                        $(field).val("");
                        cartView.setCartQuantity(cartData.totalItemsInCart);
                        cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                        cartView.hideCouponEntry();
                    });
                }
            });

            $('.connect-cart-checkout').on('click', function() {
                cartService.getWebCheckoutUrl().then(function(url) {
                    window.location = url;
                });
            });

            this.start(cartView, cartService);
        },

        start : function(cartView, cartService) {
            var self = this;
            cartView.blockCartUI();
            cartService.getActiveCart().then(function(cartData) {
                if (cartData.pricing && cartData.pricing.orderTotal) {
                    cartView.setCartQuantity(cartData.totalItemsInCart);
                    cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                    cartView.setCurrency(cartData.pricing.orderTotal.currency);
                } else {
                    self.client.shopperService.list().then(function(shopper) {
                        if (shopper.currency) {
                            cartView.setCartQuantity(cartData.totalItemsInCart);
                            cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                            cartView.setCurrency(shopper.currency);
                        } else {
                            cartView.setCurrency(config.getDefaultCurrency());
                            self.client.updateShopper({
                                currency: config.getDefaultCurrency(),
                                locale: config.getDefaultLocale()
                            }).then(function(s) {
                                cartView.setCartQuantity(cartData.totalItemsInCart);
                                cartView.updateCart(cartData, cartService.getEmptyCartOffer());
                            });
                        }
                    });
                }
            });
        },

        setOptions : function(o) {
            var self = this;
            self.options = $.extend({}, o);
            // write back several constructor args to the cofig object
            if (self.options.emptyOfferId) {
                config.setEmptyOfferId(self.options.emptyOfferId);
            }
        },

        getOptions : function() {
            return this.options;
        },

        setOption : function(k, v) {
            this.options[k] = v;
        },

        getOption : function(k) {
            return this.options[k];
        }
    });
});